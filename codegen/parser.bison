
/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ID
%token TOKEN_INTEGER
%token TOKEN_CHAR
%token TOKEN_STRING

%token TOKEN_ADD
%token TOKEN_SUBTRACT
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_ASSIGN
%token TOKEN_MODULO
%token TOKEN_EXPO
%token TOKEN_POST_INCREASE
%token TOKEN_POST_DECREASE

%token TOKEN_NOT
%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_LE
%token TOKEN_GE
%token TOKEN_EQ
%token TOKEN_NEQ
%token TOKEN_AND
%token TOKEN_OR

%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_LSQBRAC
%token TOKEN_RSQBRAC
%token TOKEN_LBRAC
%token TOKEN_RBRAC
%token TOKEN_COLON
%token TOKEN_COMA
%token TOKEN_SEMI

%token TOKEN_KEYWORD_INTEGER
%token TOKEN_KEYWORD_BOOLEAN
%token TOKEN_KEYWORD_CHAR
%token TOKEN_KEYWORD_STRING
%token TOKEN_KEYWORD_ARRAY
%token TOKEN_KEYWORD_TRUE
%token TOKEN_KEYWORD_FALSE
%token TOKEN_KEYWORD_VOID
%token TOKEN_KEYWORD_FUNCTION
%token TOKEN_KEYWORD_IF
%token TOKEN_KEYWORD_ELSE
%token TOKEN_KEYWORD_FOR
%token TOKEN_KEYWORD_PRINT
%token TOKEN_KEYWORD_RETURN

%token TOKEN_END

/*
union defines the types of the returned siemetics
*/
%union {
	struct decl* decl_ptr;
	struct type* type_ptr; 
	struct expr* expr_ptr;
	struct stmt* stmt_ptr;
	struct param_list* param_list_ptr;
	char* char_ptr;
}

/* 
type defines the non-terminal symbol
*/
%type <decl_ptr> decl_list decl;
%type <type_ptr> type;
%type <expr_ptr> expr expr_opt expr_list expr_list_non_empty item factor term term_n term_nn term_nnn term_nnnn factor_n factor_nn;
%type <char_ptr> ident;
%type <stmt_ptr> stmt stmt_list stmt_matched stmt_unmatched;
%type <param_list_ptr> param param_list not_empty_param_list;

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "expr.h"
#include "decl.h"
#include "stmt.h"
#include "type.h"
#include "symbol.h"
#include "param_list.h"

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

//#define YYSTYPE struct expr *


/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yyleng;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct decl * parser_result = 0;


%}

%%

/* Here is the grammar: program is the start symbol. */

program : decl_list TOKEN_END
	{ return 0; }
	| /* empty */ TOKEN_END
	{ parser_result = 0;  return 0;}
	;

decl_list : decl_list decl
	{ 
		struct decl *end = $1;
		while (end -> next) {
			end = end -> next;
		}
		end -> next = $2;
		$$ = $1;
	}
	| decl
	{
		$$ = $1; 
		if (!parser_result) {
			parser_result = $1;
		}
	}
	;

decl : ident TOKEN_COLON type TOKEN_ASSIGN expr TOKEN_SEMI
	{
		$$ = decl_create(DECL_VAL_INIT, $1, $3, $5, 0, 0);
	}
	| ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_LBRAC TOKEN_RBRAC TOKEN_SEMI
	{
		if ($3->kind == TYPE_FUNCTION) {
			printf("parse error: ';' not allowed after function declaration\n");
			exit(1);
		}
		$$ = decl_create(DECL_VAL_INIT, $1, $3, 0, 0, 0);	// empty array declaration
	}
	| ident TOKEN_COLON type TOKEN_SEMI
	{
		$$ = decl_create(DECL_NO_INIT, $1, $3, 0, 0, 0);
	}
	| ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_LBRAC stmt_list TOKEN_RBRAC
	{
		$$ = decl_create(DECL_CODE_INIT, $1, $3, 0, $6, 0);
	}
	| ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_LBRAC TOKEN_RBRAC
	{
		$$ = decl_create(DECL_CODE_INIT, $1, $3, 0, 0, 0);	// empty statement list
	}
	;

type : TOKEN_KEYWORD_STRING
	{
		$$ = type_create(TYPE_STRING, 0, 0);
	}
	| TOKEN_KEYWORD_INTEGER
	{
		$$ = type_create(TYPE_INTEGER, 0, 0);
	}
	| TOKEN_KEYWORD_CHAR
	{
		$$ = type_create(TYPE_CHARACTER, 0, 0);
	}
	| TOKEN_KEYWORD_BOOLEAN
	{
		$$ = type_create(TYPE_BOOLEAN, 0, 0);
	}
	| TOKEN_KEYWORD_VOID
	{
		$$ = type_create(TYPE_VOID, 0, 0);
	}
	| TOKEN_KEYWORD_ARRAY TOKEN_LSQBRAC expr_opt TOKEN_RSQBRAC type
	{
		$$ = type_create(TYPE_ARRAY, 0, $5);
		$$ -> num_subtype = $3;
	}
	| TOKEN_KEYWORD_FUNCTION type TOKEN_LPAREN param_list TOKEN_RPAREN
	{
		$$ = type_create(TYPE_FUNCTION, $4, $2);
	}
	;

ident : TOKEN_ID
	{
		char *id = malloc(sizeof(char) * strlen(yytext));
		strcpy(id, yytext);
		$$ = id;
	}
	;

param_list : /* empty */
	{
		$$ = 0;
	}
	| not_empty_param_list
	{
		$$ = $1;
	}
	;

not_empty_param_list : not_empty_param_list TOKEN_COMA param
	{
		struct param_list *end = $1;
		while (end -> next) {
			end = end -> next;
		}
		end -> next = $3;
		$$ = $1;
	}
	| param
	{
		$$ = $1;
	}
	;

param : ident TOKEN_COLON type
	{
		$$ = param_list_create($1, $3, 0);
	}
	;

stmt_list : stmt_list stmt
	{
		struct stmt* end = $1;
		while (end -> next) {
			end = end ->next;
		}
		end -> next = $2;
		$$ = $1;
	}
	| stmt
	{
		$$ = $1;
	}
	;

stmt: stmt_matched
	{ $$ = $1; }
	| stmt_unmatched
	{ $$ = $1; }
	;

stmt_matched : decl
	{
		// stmt can't be a function declaration
		if ($1->kind == DECL_CODE_INIT) {
			printf("parse error: cannot declare function insdie function!\n");
			exit(1);
		}
		$$ = stmt_create(STMT_DECL, $1, 0, 0, 0, 0, 0);
	}
	| expr TOKEN_SEMI
	{
		$$ = stmt_create(STMT_EXPR, 0, $1, 0, 0, 0, 0);
	}
	| TOKEN_KEYWORD_PRINT expr_list TOKEN_SEMI
	{
		$$ = stmt_create(STMT_PRINT, 0, $2, 0, 0, 0, 0);
	}
	| TOKEN_KEYWORD_RETURN expr TOKEN_SEMI
	{
		$$ = stmt_create(STMT_RETURN, 0, $2, 0, 0, 0, 0);
	}
	| TOKEN_KEYWORD_RETURN TOKEN_SEMI
	{
		$$ = stmt_create(STMT_RETURN, 0, 0, 0, 0, 0, 0);
	}
	| TOKEN_KEYWORD_FOR TOKEN_LPAREN expr_opt TOKEN_SEMI expr_opt TOKEN_SEMI expr_opt TOKEN_RPAREN stmt_matched
	{
		$$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0);
	}
	| TOKEN_LBRAC stmt_list TOKEN_RBRAC
	{
		$$ = stmt_create(STMT_BLOCK, 0, 0, 0, 0, $2, 0);
	}
	| TOKEN_LBRAC TOKEN_RBRAC
	{
		$$ = stmt_create(STMT_BLOCK, 0, 0, 0, 0, 0, 0);
	}
	| TOKEN_KEYWORD_IF TOKEN_LPAREN expr TOKEN_RPAREN stmt_matched TOKEN_KEYWORD_ELSE stmt_matched
	{
		$$ = stmt_create(STMT_IF_ELSE, 0, $3, 0, 0, $5, $7);
	}
	;

stmt_unmatched : TOKEN_KEYWORD_IF TOKEN_LPAREN expr TOKEN_RPAREN stmt
	{
		$$ = stmt_create(STMT_IF_ELSE, 0, $3, 0, 0, $5, 0);
	}
	| TOKEN_KEYWORD_IF TOKEN_LPAREN expr TOKEN_RPAREN stmt_matched TOKEN_KEYWORD_ELSE stmt_unmatched
	{
		$$ = stmt_create(STMT_IF_ELSE, 0, $3, 0, 0, $5, $7);
	}
	| TOKEN_KEYWORD_FOR TOKEN_LPAREN expr_opt TOKEN_SEMI expr_opt TOKEN_SEMI expr_opt TOKEN_RPAREN stmt_unmatched
	{
		$$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0);
	}
	;

expr_opt : /* empty */
	{
		$$ = 0;
	}
	| expr
	{
		$$ = $1;
	}
	;

expr : expr TOKEN_ASSIGN term_nnnn
	{
		$$ = expr_create( EXPR_ASSIGN, $1, $3 );
	}
	| term_nnnn
	{
		$$ = $1;
	}
	;

term_nnnn: term_nnnn TOKEN_OR term_nnn
	{
		$$ = expr_create( EXPR_OR, $1, $3 );
	}
	| term_nnn
	{
		$$ = $1;
	}
	;

term_nnn: term_nnn TOKEN_AND term_nn
	{
		$$ = expr_create( EXPR_AND, $1, $3 );
	}
	| term_nn
	{
		$$ = $1;
	}
	;

term_nn : term_nn TOKEN_EQ term_n
	{
		$$ = expr_create( EXPR_EQ, $1, $3 );
	}
	| term_nn TOKEN_NEQ term_n
	{
		$$ = expr_create( EXPR_NEQ, $1, $3 );
	}
	| term_nn TOKEN_LT term_n
	{
		$$ = expr_create( EXPR_LT, $1, $3 );
	}
	| term_nn TOKEN_GT term_n
	{
		$$ = expr_create( EXPR_GT, $1, $3 );
	}
	| term_nn TOKEN_LE term_n
	{
		$$ = expr_create( EXPR_LE, $1, $3 );
	}
	| term_nn TOKEN_GE term_n
	{
		$$ = expr_create( EXPR_GE, $1, $3 );
	}
	| term_n
	{
		$$ = $1;
	}
	;

term_n : term_n TOKEN_ADD term
	{
		$$ = expr_create( EXPR_ADD, $1, $3 );
	}
	| term_n TOKEN_SUBTRACT term
	{
		$$ = expr_create( EXPR_SUB, $1, $3 );
	}
	| term
	{
		$$ = $1;
	}
	;

term	: term TOKEN_MULTIPLY factor_nn
	{
		$$ = expr_create( EXPR_MUL, $1, $3 );
	}
	| term TOKEN_DIVIDE factor_nn
	{
		$$ = expr_create( EXPR_DIV, $1, $3 );
	}
	| term TOKEN_MODULO factor_nn
	{
		$$ = expr_create( EXPR_MODULO, $1, $3 );
	}
	| factor_nn
	{
		$$ = $1;
	}
	;

factor_nn : factor_nn TOKEN_EXPO factor_n
	{
		$$ = expr_create( EXPR_EXPO, $1, $3 );
	}
	| factor_n
	{
		$$ = $1;
	}

factor_n : TOKEN_NOT factor_n
	{
		$$ = expr_create( EXPR_NOT, 0, $2 );
	}
	| TOKEN_SUBTRACT factor_n
	{
		$$ = expr_create( EXPR_SUB, 0, $2 );
	}
	| factor
	{
		$$ = $1;
	}
	;

factor	: item TOKEN_POST_INCREASE
	{
		$$ = expr_create( EXPR_POST_INCREASE, $1, 0 );
	}
	| item TOKEN_POST_DECREASE
	{
		$$ = expr_create( EXPR_POST_DECREASE, $1, 0 );
	}
	| item
	{
		$$ = $1;
	}
	;

item : TOKEN_LPAREN expr TOKEN_RPAREN
	{
		$$ = $2;
	}
	| TOKEN_INTEGER
	{
		$$ = expr_create_integer_literal( atoi(yytext) );
	}
	| TOKEN_KEYWORD_TRUE
	{
		$$ = expr_create_boolean_literal(1);
	}
	| TOKEN_KEYWORD_FALSE
	{
		$$ = expr_create_boolean_literal(0);
	}
	| ident
	{
		$$ = expr_create_name($1);
	}
	| TOKEN_STRING
	{
        char newStr[yyleng];
        int curPos = 0;
        int i = 1;
        for (i = 1; i < yyleng-1; i++) {
            if (yytext[i] == '\\') {
                switch (yytext[i+1]) {
                    case 'n':
                        newStr[curPos] = '\n';
                        break;
                    case '0':
                        newStr[curPos] = '\0';
                        break;
                    default:
                        newStr[curPos] = yytext[i+1];
                        break;
                } 
                i++;
            } else {
                newStr[curPos] = yytext[i];
            }
            curPos++;
        }
        newStr[curPos] = '\0';
        if (strlen(newStr) > 255) {
            // string with more than 256 chars
            fprintf( stderr, "scann error: illegal string(cannot excceed 256 chars): %s\n", yytext );
            exit(1);
        }
		$$ = expr_create_string_literal(yytext);
	}
	| TOKEN_CHAR
	{
		char c;
        if (yyleng > 3) {
            switch (yytext[2]) {
                    case 'n':
                        c = '\n';
                        break;
                    case '0':
                        c = '\0';
                        break;
                    default:
                        c = yytext[2];
                        break;
                } 
        } else{
            c = yytext[1];
        }
		$$ = expr_create_character_literal(c);
	}
	| TOKEN_LBRAC expr_list_non_empty TOKEN_RBRAC
	{
		$$ = expr_create_array_val($2);
	}
	| ident TOKEN_LPAREN expr_list TOKEN_RPAREN
	{
		$$ = expr_create_function_call($1, $3);
	}
	| item TOKEN_LSQBRAC expr TOKEN_RSQBRAC
	{
		$$ = expr_create(EXPR_ARRAY_SUB, $1, $3);
	}

expr_list : expr_list_non_empty
	{
		$$ = $1;
	}
	| /* empty */
	{
		$$  = 0;
	}
	;

expr_list_non_empty : expr_list_non_empty TOKEN_COMA expr 
	{
		struct expr* end = $1;
		while (end -> next) {
			end = end -> next;
		}
		end -> next = $3;		
		$$ = $1;
	}
	| expr
	{
		$$ = $1;
	}
	;
%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
}
